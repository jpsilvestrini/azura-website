---
title: Middleware
description: Complete guide to middleware in AzuraJS - lifecycle, types, patterns, and best practices
icon: Plug
---

# Middleware üîå

Middleware functions are the backbone of request processing in AzuraJS, allowing you to intercept, transform, and control the flow of requests and responses throughout your application.

## What is Middleware? üìö

Middleware is a function that executes during the request-response cycle, sitting between the incoming request and your route handler. Think of middleware as a series of layers that every request passes through before reaching its final destination.

### Middleware Signature

```typescript
import type { RequestHandler, NextFunction } from "azurajs/types";

type RequestHandler = (
  req: RequestServer,
  res: ResponseServer,
  next: NextFunction;
) => void | Promise<void> | unknown;
```

Each middleware has access to:

- **Request object** (`req`) - Read and modify incoming data
- **Response object** (`res`) - Control the response
- **Next function** (`next`) - Pass control to the next middleware

### Core Capabilities

- ‚úÖ Execute code before route handlers
- ‚úÖ Modify request/response objects
- ‚úÖ End the request-response cycle early
- ‚úÖ Call the next middleware in the stack
- ‚úÖ Handle errors globally
- ‚úÖ Implement cross-cutting concerns (auth, logging, CORS, rate limiting)

## Middleware Lifecycle üîÑ

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Request   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Middleware 1 (e.g., Logging)           ‚îÇ
‚îÇ  - Log request details                  ‚îÇ
‚îÇ  - Set request ID                       ‚îÇ
‚îÇ  - Call next() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
       ‚îÇ                                    ‚îÇ
       ‚ñº                                    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  Middleware 2 (e.g., CORS)              ‚îÇ ‚îÇ
‚îÇ  - Set CORS headers                     ‚îÇ ‚îÇ
‚îÇ  - Handle preflight requests            ‚îÇ ‚îÇ
‚îÇ  - Call next() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ
       ‚îÇ                                    ‚îÇ ‚îÇ
       ‚ñº                                    ‚îÇ ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ
‚îÇ  Middleware 3 (e.g., Authentication)    ‚îÇ ‚îÇ ‚îÇ
‚îÇ  - Verify token                         ‚îÇ ‚îÇ ‚îÇ
‚îÇ  - Attach user to request               ‚îÇ ‚îÇ ‚îÇ
‚îÇ  - Call next() or reject ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ
       ‚îÇ                                    ‚îÇ ‚îÇ ‚îÇ
       ‚ñº                                    ‚îÇ ‚îÇ ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ
‚îÇ  Route Handler                          ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ  - Process business logic               ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ  - Send response                        ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ
       ‚îÇ                                    ‚îÇ ‚îÇ ‚îÇ
       ‚îÇ    Response flows back             ‚îÇ ‚îÇ ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ
                                              ‚îÇ ‚îÇ
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
       ‚îÇ                                        ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Response  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Middleware Types üéØ
‚îÇ  Middleware 3 (e.g., Authentication)    ‚îÇ
‚îÇ  - Verify token                         ‚îÇ
‚îÇ  - Call next() or reject                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Route Handler                          ‚îÇ
‚îÇ  - Process request                      ‚îÇ
‚îÇ  - Send response                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Response  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Middleware Types üéØ

### 1. Global Middleware

Applies to **all routes** in your application:

```typescript
import { AzuraClient } from "azurajs";

const app = new AzuraClient();

// Runs for every single request
app.use(async (req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  await next();
});

// Add custom header to all responses
app.use(async (req, res, next) => {
  res.setHeader("X-Powered-By", "AzuraJS");
  await next();
});
```

### 2. Route-Specific Middleware

Apply middleware to specific paths or route groups:

```typescript
// Apply to all /api/admin routes
app.use("/api/admin", adminAuthMiddleware);

// Apply to all /api/users routes  
app.use("/api/users", rateLimitMiddleware);

// Multiple middleware for a path
app.use("/api/protected", [authMiddleware, rbacMiddleware]);
```

### 3. Error Handling Middleware

Special middleware that wraps everything to catch errors:

```typescript
import { HttpError } from "azurajs/http-error";
import type { RequestHandler } from "azurajs/types";

const errorMiddleware: RequestHandler = async (req, res, next) => {
  try {
    await next();
  } catch (error: any) {
    console.error("‚ùå Error:", error);
    
    if (error instanceof HttpError) {
      res.status(error.status).json({
        error: error.message,
        code: error.code
      });
    } else {
      res.status(500).json({
        error: "Internal server error"
      });
    }
  }
};

// Register error middleware first (wraps everything)
app.use(errorMiddleware);
```

## Creating Middleware üõ†Ô∏è

### Basic Middleware

#### TypeScript

```typescript
import type { RequestHandler } from "azurajs/types";

// Simple logging middleware
const loggingMiddleware: RequestHandler = async (req, res, next) => {
  const start = Date.now();
  console.log(`‚û°Ô∏è  ${req.method} ${req.url}`);
  
  await next();
  
  const duration = Date.now() - start;
  console.log(`‚úÖ ${req.method} ${req.url} - ${duration}ms`);
};
```

#### JavaScript

```javascript
// Simple logging middleware
const loggingMiddleware = async (req, res, next) => {
  const start = Date.now();
  console.log(`‚û°Ô∏è  ${req.method} ${req.url}`);
  
  await next();
  
  const duration = Date.now() - start;
  console.log(`‚úÖ ${req.method} ${req.url} - ${duration}ms`);
};
```

### Middleware with Configuration

Create factory functions for configurable middleware:

#### TypeScript

```typescript
function createAuthMiddleware(options: { secret: string; issuer: string }): RequestHandler {
  return async (req, res, next) => {
    const token = req.headers.authorization?.replace("Bearer ", "");
    
    if (!token) {
      res.status(401).json({ error: "No token provided" });
      return;
    }
    
    try {
      const payload = await verifyJWT(token, options.secret, options.issuer);
      (req as any).user = payload;
      await next();
    } catch (error) {
      res.status(401).json({ error: "Invalid token" });
    }
  };
}

// Usage
const authMiddleware = createAuthMiddleware({
  secret: process.env.JWT_SECRET!,
  issuer: "azurajs-app"
});

app.use(authMiddleware);
```

#### JavaScript

```javascript
function createAuthMiddleware(options) {
  return async (req, res, next) => {
    const token = req.headers.authorization?.replace("Bearer ", "");
    
    if (!token) {
      res.status(401).json({ error: "No token provided" });
      return;
    }
    
    try {
      const payload = await verifyJWT(token, options.secret, options.issuer);
      req.user = payload;
      await next();
    } catch (error) {
      res.status(401).json({ error: "Invalid token" });
    }
  };
}

// Usage
const authMiddleware = createAuthMiddleware({
  secret: process.env.JWT_SECRET,
  issuer: "azurajs-app"
});

app.use(authMiddleware);
```

## Practical Examples üí°

### 1. Authentication Middleware

Verify JWT tokens and attach user to request:

```typescript
import { HttpError } from "azurajs/http-error";
import type { RequestHandler } from "azurajs/types";
import jwt from "jsonwebtoken";

export const authMiddleware: RequestHandler = async (req, res, next) => {
  const token = req.headers.authorization?.replace("Bearer ", "");
  
  if (!token) {
    res.status(401).json({ error: "Authentication required" });
    return;
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
    (req as any).user = {
      id: decoded.userId,
      email: decoded.email,
      role: decoded.role
    };
    await next();
  } catch (error) {
    res.status(401).json({ error: "Invalid or expired token" });
  }
};
```

### 2. Logging Middleware with Colors

Enhanced logging with request timing:

```typescript
const colors = {
  reset: "\\x1b[0m",
  green: "\\x1b[32m",
  yellow: "\\x1b[33m",
  blue: "\\x1b[34m",
  red: "\\x1b[31m"
};

const loggingMiddleware: RequestHandler = async (req, res, next) => {
  const start = Date.now();
  const timestamp = new Date().toISOString();
  
  console.log(
    `${colors.blue}[${timestamp}]${colors.reset} ` +
    `${colors.yellow}${req.method}${colors.reset} ${req.url}`
  );
  
  await next();
  
  const duration = Date.now() - start;
  const color = duration < 100 ? colors.green : duration < 500 ? colors.yellow : colors.red;
  
  console.log(
    `${colors.blue}[${timestamp}]${colors.reset} ` +
    `${colors.yellow}${req.method}${colors.reset} ${req.url} - ` +
    `${color}${duration}ms${colors.reset}`
  );
};
```

### 3. CORS Middleware

Handle Cross-Origin Resource Sharing:

```typescript
interface CorsOptions {
  origin: string | string[];
  methods?: string[];
  allowedHeaders?: string[];
  credentials?: boolean;
  maxAge?: number;
}

function createCorsMiddleware(options: CorsOptions): RequestHandler {
  return async (req, res, next) => {
    const origin = Array.isArray(options.origin) 
      ? options.origin.join(", ")
      : options.origin;
    
    res.setHeader("Access-Control-Allow-Origin", origin);
    res.setHeader(
      "Access-Control-Allow-Methods",
      (options.methods || ["GET", "POST", "PUT", "DELETE", "PATCH"]).join(", ")
    );
    res.setHeader(
      "Access-Control-Allow-Headers",
      (options.allowedHeaders || ["Content-Type", "Authorization"]).join(", ")
    );
    
    if (options.credentials) {
      res.setHeader("Access-Control-Allow-Credentials", "true");
    }
    
    if (options.maxAge) {
      res.setHeader("Access-Control-Max-Age", String(options.maxAge));
    }
    
    // Handle preflight requests
    if (req.method === "OPTIONS") {
      res.status(204).end();
      return;
    }
    
    await next();
  };
}

// Usage
app.use(createCorsMiddleware({
  origin: ["http://localhost:3000", "https://myapp.com"],
  methods: ["GET", "POST", "PUT", "DELETE"],
  credentials: true,
  maxAge: 86400
}));
```

### 4. Rate Limiting Middleware

Protect your API from abuse:

```typescript
interface RateLimitStore {
  count: number;
  resetAt: number;
}

function createRateLimitMiddleware(
  maxRequests: number,
  windowMs: number
): RequestHandler {
  const store = new Map<string, RateLimitStore>();
  
  // Cleanup old entries every minute
  setInterval(() => {
    const now = Date.now();
    for (const [key, value] of store.entries()) {
      if (now > value.resetAt) {
        store.delete(key);
      }
    }
  }, 60000);
  
  return async (req, res, next) => {
    const ip = req.socket.remoteAddress || "unknown";
    const now = Date.now();
    
    let record = store.get(ip);
    
    if (!record || now > record.resetAt) {
      record = { count: 1, resetAt: now + windowMs };
      store.set(ip, record);
      await next();
      return;
    }
    
    record.count++;
    
    if (record.count > maxRequests) {
      res.setHeader("X-RateLimit-Limit", String(maxRequests));
      res.setHeader("X-RateLimit-Remaining", "0");
      res.setHeader("X-RateLimit-Reset", String(record.resetAt));
      
      res.status(429).json({
        error: "Too many requests",
        retryAfter: Math.ceil((record.resetAt - now) / 1000)
      });
      return;
    }
    
    res.setHeader("X-RateLimit-Limit", String(maxRequests));
    res.setHeader("X-RateLimit-Remaining", String(maxRequests - record.count));
    res.setHeader("X-RateLimit-Reset", String(record.resetAt));
    
    await next();
  };
}

// Usage: 100 requests per minute
app.use(createRateLimitMiddleware(100, 60000));
```

### 5. Request Timing Middleware

Add response time header:

```typescript
const timingMiddleware: RequestHandler = async (req, res, next) => {
  const start = process.hrtime.bigint();
  
  await next();
  
  const end = process.hrtime.bigint();
  const duration = Number(end - start) / 1000000; // Convert to milliseconds
  
  res.setHeader("X-Response-Time", `${duration.toFixed(2)}ms`);
};
```

### 6. Request ID Middleware

Track requests with unique IDs:

```typescript
import { randomUUID } from "crypto";

const requestIdMiddleware: RequestHandler = async (req, res, next) => {
  const requestId = req.headers["x-request-id"] || randomUUID();
  
  (req as any).id = requestId;
  res.setHeader("X-Request-ID", requestId);
  
  await next();
};
```

### 7. Body Size Limit Middleware

Prevent large payload attacks:

```typescript
function createBodySizeLimitMiddleware(maxSize: number): RequestHandler {
  return async (req, res, next) => {
    const contentLength = parseInt(req.headers["content-length"] || "0", 10);
    
    if (contentLength > maxSize) {
      res.status(413).json({
        error: "Payload too large",
        maxSize,
        received: contentLength
      });
      return;
    }
    
    await next();
  };
}

// Usage: 10MB limit
app.use(createBodySizeLimitMiddleware(10 * 1024 * 1024));
```

### 8. Compression Middleware

Compress responses to save bandwidth:

```typescript
import { gzipSync, brotliCompressSync } from "zlib";

const compressionMiddleware: RequestHandler = async (req, res, next) => {
  const acceptEncoding = req.headers["accept-encoding"] || "";
  
  // Store original send method
  const originalSend = res.send?.bind(res);
  
  if (!originalSend) {
    await next();
    return;
  }
  
  // Override send method
  res.send = function(data: any) {
    if (typeof data !== "string" && !Buffer.isBuffer(data)) {
      return originalSend(data);
    }
    
    const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data);
    
    // Only compress if size > 1KB
    if (buffer.length < 1024) {
      return originalSend(data);
    }
    
    if (acceptEncoding.includes("br")) {
      const compressed = brotliCompressSync(buffer);
      res.setHeader("Content-Encoding", "br");
      return originalSend(compressed);
    } else if (acceptEncoding.includes("gzip")) {
      const compressed = gzipSync(buffer);
      res.setHeader("Content-Encoding", "gzip");
      return originalSend(compressed);
    }
    
    return originalSend(data);
  };
  
  await next();
};
```

## Execution Order and Precedence ‚ö°

Middleware executes in the order it's registered:

```typescript
const app = new AzuraClient();

// 1. Error wrapper (first to catch everything)
app.use(errorMiddleware);

// 2. Request ID
app.use(requestIdMiddleware);

// 3. Timing
app.use(timingMiddleware);

// 4. Logging
app.use(loggingMiddleware);

// 5. Compression
app.use(compressionMiddleware);

// 6. CORS
app.use(corsMiddleware);

// 7. Body size limit
app.use(createBodySizeLimitMiddleware(10 * 1024 * 1024));

// 8. Rate limiting
app.use(createRateLimitMiddleware(100, 60000));

// 9. Authentication (optional for some routes)
app.use(conditionalAuthMiddleware);

// 10. Your routes
applyDecorators(app, [UserController, ProductController]);

// The order ensures:
// - Errors are caught first
// - Requests are logged with IDs
// - Rate limiting before heavy processing
// - Auth last before routes
```

## Custom Middleware Patterns üé®

### Conditional Middleware

Apply middleware based on conditions:

```typescript
const conditionalAuthMiddleware: RequestHandler = async (req, res, next) => {
  // Skip auth for public routes
  const publicRoutes = ["/api/public", "/health", "/metrics"];
  
  if (publicRoutes.some(route => req.url?.startsWith(route))) {
    await next();
    return;
  }
  
  // Apply auth for other routes
  await authMiddleware(req, res, next);
};
```

### Middleware Composition

Combine multiple middleware:

```typescript
function composeMiddleware(...middlewares: RequestHandler[]): RequestHandler {
  return async (req, res, next) => {
    let index = 0;
    
    const dispatch = async (): Promise<void> => {
      if (index >= middlewares.length) {
        await next();
        return;
      }
      
      const middleware = middlewares[index++];
      await middleware(req, res, dispatch);
    };
    
    await dispatch();
  };
}

// Usage
const protectedRoute = composeMiddleware(
  authMiddleware,
  rbacMiddleware,
  auditMiddleware
);

app.use("/api/admin", protectedRoute);
```

## Express Middleware Compatibility üîÑ

AzuraJS middleware is compatible with Express middleware:

```typescript
import helmet from "helmet";
import compression from "compression";
import cookieParser from "cookie-parser";

const app = new AzuraClient();

// Use Express middleware directly
app.use(helmet());
app.use(compression());
app.use(cookieParser());
```

## Error Handling in Middleware ‚ö†Ô∏è

### Try-Catch Pattern

```typescript
const safeMiddleware: RequestHandler = async (req, res, next) => {
  try {
    // Your middleware logic
    const data = await fetchExternalData();
    (req as any).externalData = data;
    await next();
  } catch (error) {
    console.error("Middleware error:", error);
    res.status(500).json({ error: "Middleware failed" });
  }
};
```

### Error Propagation

Pass errors to error handling middleware:

```typescript
const middlewareWithErrors: RequestHandler = async (req, res, next) => {
  try {
    const user = await database.getUser(userId);
    if (!user) {
      throw new HttpError(404, "User not found");
    }
    (req as any).user = user;
    await next();
  } catch (error) {
    // Error will be caught by error middleware
    throw error;
  }
};
```

## Async Middleware Patterns üîÑ

### Sequential Async Operations

```typescript
const dataFetchMiddleware: RequestHandler = async (req, res, next) => {
  try {
    // Run sequentially
    const user = await database.getUser(userId);
    const permissions = await database.getPermissions(user.id);
    const settings = await database.getSettings(user.id);
    
    (req as any).user = user;
    (req as any).permissions = permissions;
    (req as any).settings = settings;
    
    await next();
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch data" });
  }
};
```

### Parallel Async Operations

```typescript
const parallelDataMiddleware: RequestHandler = async (req, res, next) => {
  try {
    // Run in parallel for better performance
    const [user, permissions, settings] = await Promise.all([
      database.getUser(userId),
      database.getPermissions(userId),
      database.getSettings(userId)
    ]);
    
    (req as any).user = user;
    (req as any).permissions = permissions;
    (req as any).settings = settings;
    
    await next();
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch data" });
  }
};
```

## Best Practices & Performance Tips üíé

### 1. Always Call `next()`

```typescript
// ‚ùå Bad - request hangs
const badMiddleware: RequestHandler = async (req, res, next) => {
  console.log("Processing...");
  // Forgot to call next()!
};

// ‚úÖ Good
const goodMiddleware: RequestHandler = async (req, res, next) => {
  console.log("Processing...");
  await next(); // Always call next
};
```

### 2. Use Async/Await

```typescript
// ‚ùå Bad - no await
const badMiddleware: RequestHandler = async (req, res, next) => {
  fetchData().then(() => next()); // Promise not awaited
};

// ‚úÖ Good  
const goodMiddleware: RequestHandler = async (req, res, next) => {
  await fetchData();
  await next();
};
```

### 3. Order Matters

```typescript
// ‚ùå Bad - auth before CORS
app.use(authMiddleware);  // May fail on OPTIONS
app.use(corsMiddleware);

// ‚úÖ Good - CORS first
app.use(corsMiddleware);  // Handle OPTIONS first
app.use(authMiddleware);
```

### 4. Keep Middleware Focused

```typescript
// ‚ùå Bad - doing too much
const godMiddleware: RequestHandler = async (req, res, next) => {
  // Logging, auth, validation, transformation...
  // 100 lines of code
};

// ‚úÖ Good - single responsibility
const loggingMiddleware: RequestHandler = async (req, res, next) => {
  console.log(req.method, req.url);
  await next();
};

const authMiddleware: RequestHandler = async (req, res, next) => {
  await verifyAuth(req);
  await next();
};
```

### 5. Use Caching for Expensive Operations

```typescript
const cache = new Map<string, any>();

const cachedMiddleware: RequestHandler = async (req, res, next) => {
  const key = req.url;
  
  if (cache.has(key)) {
    (req as any).cached = cache.get(key);
    await next();
    return;
  }
  
  const data = await expensiveOperation();
  cache.set(key, data);
  (req as any).cached = data;
  
  await next();
};
```

### 6. Cleanup Resources

```typescript
const resourceMiddleware: RequestHandler = async (req, res, next) => {
  const connection = await database.connect();
  
  try {
    (req as any).db = connection;
    await next();
  } finally {
    // Always cleanup
    await connection.close();
  }
};
```

## Testing Middleware üß™

### Unit Testing

```typescript
import { describe, it, expect, mock } from "bun:test";

describe("Auth Middleware", () => {
  it("should reject requests without token", async () => {
    const req = {
      headers: {}
    } as any;
    
    const res = {
      status: mock((code: number) => res),
      json: mock((data: any) => res)
    } as any;
    
    const next = mock(async () => {});
    
    await authMiddleware(req, res, next);
    
    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.json).toHaveBeenCalledWith({ error: "Authentication required" });
    expect(next).not.toHaveBeenCalled();
  });
  
  it("should accept valid tokens", async () => {
    const req = {
      headers: {
        authorization: "Bearer valid-token"
      }
    } as any;
    
    const res = {} as any;
    const next = mock(async () => {});
    
    await authMiddleware(req, res, next);
    
    expect(req.user).toBeDefined();
    expect(next).toHaveBeenCalled();
  });
});
```

## Troubleshooting Common Issues üîß

### Issue: Request Hangs

**Cause**: Forgot to call `next()`

```typescript
// ‚ùå Bad
const middleware: RequestHandler = async (req, res, next) => {
  console.log("Processing...");
  // Forgot next()!
};

// ‚úÖ Fix
const middleware: RequestHandler = async (req, res, next) => {
  console.log("Processing...");
  await next();
};
```

### Issue: Headers Already Sent

**Cause**: Calling `res.json()` before `next()`

```typescript
// ‚ùå Bad
const middleware: RequestHandler = async (req, res, next) => {
  res.json({ data: "something" });
  await next(); // Headers already sent!
};

// ‚úÖ Fix  
const middleware: RequestHandler = async (req, res, next) => {
  if (someCondition) {
    res.json({ data: "something" });
    return; // Don't call next
  }
  await next();
};
```

### Issue: Middleware Not Executing

**Cause**: Registered after routes

```typescript
// ‚ùå Bad
applyDecorators(app, [Controllers]);
app.use(middleware); // Too late!

// ‚úÖ Fix
app.use(middleware);
applyDecorators(app, [Controllers]);
```

## Complete Example: Production-Ready Setup üöÄ

```typescript
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import type { RequestHandler } from "azurajs/types";

const app = new AzuraClient();

// 1. Error handling wrapper
app.use(errorMiddleware);

// 2. Request ID and timing
app.use(requestIdMiddleware);
app.use(timingMiddleware);

// 3. Logging
app.use(loggingMiddleware);

// 4. Security
app.use(createCorsMiddleware({
  origin: process.env.ALLOWED_ORIGINS!.split(","),
  credentials: true
}));

app.use(helmet());

// 5. Body size limit
app.use(createBodySizeLimitMiddleware(10 * 1024 * 1024));

// 6. Rate limiting
app.use(createRateLimitMiddleware(100, 60000));

// 7. Compression
app.use(compressionMiddleware);

// 8. Conditional auth
app.use(conditionalAuthMiddleware);

// 9. Your routes
applyDecorators(app, [
  UserController,
  ProductController,
  OrderController
]);

// Start server
await app.listen();
console.log("üöÄ Servidor rodando em http://localhost:3000");
```

## Next Steps üìñ

Now that you understand middleware, explore these related topics:

- [**Validation**](validation) - Validate request data with middleware
- [**Cookies**](cookies) - Handle cookies in middleware
- [**Error Handling**](error-handling) - Advanced error handling patterns
- [**CORS**](cors) - Deep dive into CORS configuration

---

**Pro Tip**: Middleware order is crucial. Place error handling first, logging second, security third, and authentication last before your routes.
